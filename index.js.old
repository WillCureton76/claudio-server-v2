require('dotenv').config();
const fs = require('fs');
const path = require('path');
const express = require('express');
const cors = require('cors');
const fetch = (...args) => import('node-fetch').then(({default: f}) => f(...args));
const { createConversation, append, snapshot } = require('./conversations');

const PORT = process.env.PORT || 8787;
const app = express();
app.use(cors());
app.use(express.json({ limit: '2mb' }));

app.get('/healthz', (_, res) => res.json({ ok: true }));

function loadPersona() {
  const p1 = path.join(__dirname, 'persona.md');
  const p2 = path.join(__dirname, 'persona.example.md');
  if (fs.existsSync(p1)) return fs.readFileSync(p1, 'utf8').trim();
  if (fs.existsSync(p2)) return fs.readFileSync(p2, 'utf8').trim();
  return "You are Moneypenny, a concise voice copilot. No filler.";
}

app.post('/boot', (req, res) => {
  const seed = Array.isArray(req.body?.seed) ? req.body.seed : null;
  const persona = loadPersona();
  const initial = seed && seed.length ? seed : [{ role: 'system', text: persona }];
  const id = createConversation(initial);
  return res.json({ conversation_id: id, seeded: true });
});

app.post('/conversation/init', (req,res) => {
  const seed = Array.isArray(req.body?.seed) ? req.body.seed : [];
  const id = createConversation(seed);
  res.json({ conversation_id: id });
});
app.post('/conversation/append', (req,res) => {
  const id = String(req.body?.conversation_id || '');
  const msgs = Array.isArray(req.body?.msgs) ? req.body.msgs : [];
  if (!id) return res.status(400).json({ error: 'conversation_id required' });
  append(id, ...msgs);
  res.json({ ok:true });
});
app.get('/conversation/snapshot', (req,res) => {
  const id = String(req.query?.id || '');
  if (!id) return res.status(400).json({ error: 'id required' });
  res.json({ items: snapshot(id) });
});

app.post('/respond', async (req, res) => {
  try {
    const id = String(req.body?.conversation_id || '');
    const text = String(req.body?.text || '');
    if (!id || !text) return res.status(400).json({ error: 'conversation_id and text required' });

    const history = snapshot(id);
    const messages = [...history, { role: 'user', text }].map(m => ({
      role: m.role,
      content: [{ type: 'text', text: m.text }]
    }));

    const r = await fetch('https://api.openai.com/v1/responses', {
      method: 'POST',
      headers: {
        Authorization: `Bearer ${process.env.OPENAI_API_KEY}`,
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({
        model: 'gpt-5',
        input: messages,
        stream: true
      })
    });

    if (!r.ok || !r.body) {
      const errTxt = await r.text().catch(()=>''); 
      return res.status(r.status || 502).json({ error: 'openai responses failed', detail: errTxt });
    }

    res.setHeader('Content-Type', 'application/x-ndjson; charset=utf-8');
    res.setHeader('Transfer-Encoding', 'chunked');

    const reader = r.body.getReader();
    const decoder = new TextDecoder();
    let buf = '';
    let assistantText = '';

    while (true) {
      const { value, done } = await reader.read();
      if (done) break;
      buf += decoder.decode(value, { stream: true });
      const parts = buf.split('\n');
      buf = parts.pop() || '';
      for (const line of parts) {
        const trimmed = line.trim();
        if (!trimmed) continue;
        if (!trimmed.startsWith('data:')) continue;
        const jsonStr = trimmed.slice(5).trim();
        if (jsonStr === '[DONE]') continue;
        let ev;
        try { ev = JSON.parse(jsonStr); } catch { continue; }
        const t = ev?.type || ev?.event || '';
        if (t === 'response.output_text.delta' && typeof ev.delta === 'string') {
          assistantText += ev.delta;
          res.write(JSON.stringify({ delta: ev.delta }) + '\n');
        }
      }
    }

    if (assistantText) append(id, { role: 'assistant', text: assistantText });
    res.end();
  } catch (err) {
    console.error('respond error', err);
    if (!res.headersSent) res.status(500).json({ error: 'respond failed' });
    else try { res.end(); } catch {}
  }
});

app.get('/tts-dia', async (req, res) => {
  try {
    const endpoint = process.env.DIA_TTS_ENDPOINT;
    if (!endpoint) return res.status(400).json({ error: 'DIA_TTS_ENDPOINT not set' });
    const text = String(req.query?.text || '');
    const voice = String(req.query?.voice || 'default');
    if (!text) return res.status(400).json({ error: 'text required' });

    const r = await fetch(endpoint, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        ...(process.env.DIA_API_KEY ? { Authorization: `Bearer ${process.env.DIA_API_KEY}` } : {})
      },
      body: JSON.stringify({ text, voice })
    });

    const ctype = (r.headers.get('content-type') || '').toLowerCase();
    if (ctype.includes('application/json')) {
      const j = await r.json();
      const url = j.audio_url || j.url;
      if (!url) return res.status(502).json({ error: 'DIA: missing audio_url' });
      const a = await fetch(url);
      res.setHeader('Content-Type', a.headers.get('content-type') || 'audio/mpeg');
      return a.body.pipe(res);
    }
    res.setHeader('Content-Type', r.headers.get('content-type') || 'audio/mpeg');
    r.body.pipe(res);
  } catch (err) {
    console.error('tts-dia error', err);
    if (!res.headersSent) res.status(500).json({ error: 'tts-dia failed' }); else try { res.end(); } catch {}
  }
});
// ========= ADD THIS RIGHT HERE (line ~142, before app.listen) =========
// Mount MCP hub
(async () => {
  try {
    const { mountMCP } = require('./lib/mcp');
    await mountMCP(app);
    console.log('[MCP] Hub mounted successfully');
  } catch (e) {
    console.error('[MCP] Failed to mount hub:', e);
    // Don't crash server if MCP fails
  }
})();

// This line stays as is:
app.listen(PORT, () => console.log(`plain-voice v3 server (boot) on :${PORT}`));
